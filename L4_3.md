##  2pg.

Multi-object Program
- 각각의 object가 자신의 lock과 cv를 가져야 한다.
- 뭐 필요한거 슥 적어둔 듯 뒤에 나오겠지

## 4pg.

Topic
- multiprocessor cache coherence
- MCS locks(locks이 주로 busy일때 즉 사용중일때)
- RCU locks(locks가 주로 busy이고, data가 주로 read-only일때)

## 5pg.

Multiprocessor cahce coherence(캐시 일관성)  

시나리오
- thread A는 critical section에서 data를 수정했고 lock을 해제
- threa B가 lock을 얻고 data 읽기
- 모든 access가 main memory를 이용하연 쉽다.

## 6pg.

Write-back Cache Coherence

Cache coherence
- system은 data의 copy가 있는 것처럼 행동한다.
- data가 read되는 경우, 여러 cache에서 copy를 가질 수 있다.
- data가 modify되는 경우, 최대 한 cache만 copy 가능.

On write
- write하기 전에 모든 cached copy들을 invalidate한다.
- 수정된 data는 cache에 남아있다.
저게 바로 write back이다.
어짜피 도느니는 아키 안들어서 모를테니 설명하고 넘어간다.
write back과 write through가 상반된 개념이다.
write back은 main memory에 쓰는 것이 아니라 cache에 써두었다가, 필요할 때 main memory를 업데이트 하는 방식이다.
write through는 cache와 main memory에 둘 다 쓰는 것이다.

On read
- 값을 owner나 memory에서 가져온다.

## 7pg.

걍 슥 보고 넘어가자.  

## 8pg.

Directory-based Cache Coherence  

cached location을 어떻게 알까
- H/W는 모든 cached copy를 추적한다.
- read miss 발생 시, 최근 copy를 가져와서 invalidate
- write miss 발생 시, 모든 copy invalidate

Read-modify-write instructions
– cache entry를 독점적으로 가져와, complete될 때까지 다른 cache가 data를 읽지 못하게 한다.  

## 9pg.

앞에서 보았던 spinlock으로 보호.

## 10pg.

대충 보기.  

## 11pg.

Reducing lock contention(경쟁)  

Fine-gained locking
- object를 subset으로 나누어, 각각이 자신의 lock으로 보호된다.

Per-processor data structure
- object를 분할하여 대부분의 access가 한 processor에서 이루어짐.

Ownership/staged architecture
- 한번에 하나의 thread만 shared data를 access

## 12pg.

What if Locks are still mostly busy?  

MCS lock
- lock이 경쟁할때를 위해 lock 구현 최적화

RCU(read-copy-update)
- 효율적인 readers,writers lock(in linux)
- reader는 first acquiring lock 없이 진행한다.
- writer는 reader가 끝났음을 보장한다.

둘다 atomic read-modify-write instructions 의존.  

## 13pg.

앞 ppt에서 spinlock인가 할 때 등장했던 test_and_set이다.  
test하고 원래 값을 return하며, 값을 busy(true)로 바꿔둔다.  

만약 많은 processor가 동시에 lock을 acquire하면 어떻게 될까
- T&S는 많은 cache coherency traffic을 발생한다.
- lock을 경쟁하는 cpu간의 FIFO 순서를 보장 안한다.

## 14pg.

뭐 대충 P1이 lock을 가지고 있어서 P2랑 P3가 t&s 실행하고 update 못하고 있는 상황인 것 같다.  

## 15pg ~ 17pg.

이제 t&S에 test를 하나 더 추가한 코드이다.  

만약 많은 processor가 동시에 lock을 acquire하면 어떻게 될까
- 아직 T&S에 의존
- lock을 경쟁하는 cpu간의 FIFO 순서를 보장 안한다.
- Lock value pings between caches 

Test를 하나 더 추가하면 왜 더 성능이 좋을까?
- 아마 다음 page 그림을 봐서는 일단 test를 먼저 해서 t&s을 실행 안해도 되는 경우를 미리 거르는 작업을 해주는 것 같다.


## 18pg.

spin lock에 delay를 준다
- 도음은 되지만 경쟁이 없다면 느려진다.

Spin adaptively
- waiting이 적으면 no delay
- waiting 많으면 long delay -> wait time으로 waiter의 수 추정

MCS
- compareAndSwap을 이용하여 waiters의 linked list를 만든다.
- processor당 location에 spin

## 19pg.

Atomic compareAndSwap
- memory word에서 작동
- memory word 값이 예상과 다른지 확인한다.(다르지 않다면 다른 thread들이 compareAndSwap을 먼저 실행 안한거다)
- changed되었다면 return an error(and loop)
- not changed면, memory word를 new value로 set

## 20pg.

MCS lock  

lock을 waiting하는 thread list를 유지한다.
- list의 front가 lock을 hold
- MCSLock::tail은 list의 last thread
- new thread는 compareAndSwap을 이용하여 tail에 추가된다.
- lock은  next->needToWait = FALSE;으로 새팅되어 넘어간다.
- next thread는 자신의 needToWait가 true이면 spin

## 21pg ~ 22pg.

acquire 함수를 보자.
- compareAndSwap으로 변하지 않으면 oldtail = tail
- 만약 oldTail != Null이면 기다려야 하므로 oldtail->next를 mytcb로 정해주고, needToWait가 false가 될 때까지 spin

release 함수를 보자.
- if 문으로 change 되었다면, tail == MyTCB인 경우 마지막이니깐 free
- else 문으로 myTCB->next가 NULL이 될 떄까지 spin될고 next의 needtoWait을 false로 만들어준다.

## 23pg.

RCU(Read-Copy-Update)  

shared data를 빠르게 읽는 것을 목표로 한다.
- first acquiring a lock 없이 read 진행
- write가 느려도 괜찮다.

Restricted update
- writer는 data structure의 new version 계산
- new version을 single atomic instrcution으로 publish

Multiple concurrent version
- reader는 old나 new version을 볼 수 있다.

integeration with thread scheduler
- 모든 reader가 grace period 안에 끝나는 것을 보장하고, old version을 garbage collect한다.

## 24pg.

이제 grace period 전에는 old version을 read한다.  
write가 끝나면 new version이 되고, grace period아네서 read를 하면 new version을 읽는다.  
만약 grace period 전에 read 하는데 version이 new가 되면 old나 new를 read하게 된다.  
만약 grace period가 끝나면 old version을 garbage collect 한다.  

## 25pg.

reader는 entry에서 interrupt를 비활성화 한다.
- 이는 critical section에서 read가 재때 완료될 것을 보장한다.
- read or write lock이 없다.

Writer
- write lock 을 얻는다.
- new sata structure 계산
- new version을 atomic instruction으로 publish
- release write lock
- grace period동안 wait
- wait 끝나면 old version garbage collect

## 26pg.

Non-blocking synchronization  

목표 : data structure가 lock 없이 읽고 수정할 수 있게 한다.
- lock 경쟁이 없고 deadlock이 발생 안한다.

일반적인 방법은 compareandswap을 이용하는 것이다.
- data structure copy를 만든다.
- copy를 수정한다
- 아무도 접근 안하면 new version으로 swap
- pointer가 변경된 경우 다시 시작

